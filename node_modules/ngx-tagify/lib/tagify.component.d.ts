import { AfterViewInit, ElementRef, EventEmitter, OnDestroy } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { Observable } from 'rxjs';
import { TagData, TagifySettings } from '@yaireo/tagify';
import { TagifyService } from './tagify.service';
import * as ɵngcc0 from '@angular/core';
export declare class TagifyComponent implements AfterViewInit, ControlValueAccessor, OnDestroy {
    private tagifyService;
    private element;
    private valueData;
    private valueType;
    private onChange;
    private onTouched;
    private unsubscribe$;
    private value$;
    private tagify;
    private skip;
    inputClassValue: string;
    readonlyValue: boolean;
    inputRef: ElementRef<HTMLInputElement>;
    settings: TagifySettings;
    name: string;
    whitelist: Observable<string[] | TagData[]>;
    set inputClass(v: string);
    set readonly(v: boolean);
    get value(): string | TagData[];
    set value(v: string | TagData[]);
    add: EventEmitter<any>;
    remove: EventEmitter<any>;
    tInput: EventEmitter<string>;
    constructor(tagifyService: TagifyService, element: ElementRef<HTMLElement>);
    ngAfterViewInit(): void;
    writeValue(tags: string | TagData[]): void;
    registerOnChange(fn: any): void;
    registerOnTouched(fn: any): void;
    private setValue;
    /**
     * Tagify creates a `tags` element to which the classes of the `input` element are applied.
     * Changes of `inputClass` are applied automatically to the `input` element, but have to be
     * manually applied to the `tags` element.
     */
    private setTagsClass;
    private setReadonly;
    ngOnDestroy(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<TagifyComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<TagifyComponent, "tagify", never, { "settings": "settings"; "name": "name"; "inputClass": "inputClass"; "readonly": "readonly"; "whitelist": "whitelist"; }, { "add": "add"; "remove": "remove"; "tInput": "tInput"; }, never, ["*"]>;
}

//# sourceMappingURL=tagify.component.d.ts.map